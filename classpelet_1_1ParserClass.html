<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>pelet: pelet::ParserClass Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">pelet
   
   </div>
   <div id="projectbrief">Php Easy LanguagE Toolkit. A C++ library for analyzing PHP source code</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacepelet.html">pelet</a>      </li>
      <li class="navelem"><a class="el" href="classpelet_1_1ParserClass.html">ParserClass</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">pelet::ParserClass Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="pelet::ParserClass" -->
<p><code>#include &lt;<a class="el" href="ParserClass_8h_source.html">ParserClass.h</a>&gt;</code></p>

<p><a href="classpelet_1_1ParserClass-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#ade97bfbc6cf913b6a45ba9cde128d327">ScanFile</a> (const std::string &amp;file, <a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;results)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#af27f8856c5b45bb97aebb18df35e1e7b">ScanFile</a> (FILE *file, const UnicodeString &amp;fileName, <a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;results)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#a3e856ab140ed7cd6aacd6bce2fa5b79c">ScanString</a> (const UnicodeString &amp;code, <a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;results)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#a04891b90521c6be1d2cd27c94df4636e">SetVersion</a> (Versions version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#aa6ad091dd5bb49c73f4fdf5a04b97fd2">SetClassObserver</a> (<a class="el" href="classpelet_1_1ClassObserverClass.html">ClassObserverClass</a> *observer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#a9ca52d29b89310caa2e2f25412d4304b">SetClassMemberObserver</a> (<a class="el" href="classpelet_1_1ClassMemberObserverClass.html">ClassMemberObserverClass</a> *observer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#a6a3418882ddc19eb974728ead1e66ec6">SetFunctionObserver</a> (<a class="el" href="classpelet_1_1FunctionObserverClass.html">FunctionObserverClass</a> *observer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#a9b84fa65457694a1b966ce30ea956882">SetVariableObserver</a> (<a class="el" href="classpelet_1_1VariableObserverClass.html">VariableObserverClass</a> *observer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#a4aabf1aeee74f8ddd1b855274cc607c3">SetExpressionObserver</a> (<a class="el" href="classpelet_1_1ExpressionObserverClass.html">ExpressionObserverClass</a> *expressionObserver)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#ace9830c4b9017efb6eaaef8fd967721f">LintFile</a> (const std::string &amp;file, <a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;results)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#a1f47611a12e60ceaa159cf36c4c1230f">LintFile</a> (FILE *file, const UnicodeString &amp;filename, <a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;results)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#a9b522bb72e910d102e90f686f65def41">LintString</a> (const UnicodeString &amp;code, <a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;results)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#ae5d4647996e516a462eb1f5c3433cbdd">GetCharacterPosition</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html#a8cd9079de3a4f9ac07d7eda0575b7e27">ParseExpression</a> (UnicodeString expressionString, <a class="el" href="classpelet_1_1VariableClass.html">pelet::VariableClass</a> &amp;variable)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The parser class is designed in a way that can utilized by different pieces of code. The parser will analyze given code and make calls to the different registered observers. There are observers for classes, functions, and methods. Not all observers have to be set; for example if a <a class="el" href="classpelet_1_1FunctionObserverClass.html">FunctionObserverClass</a> is never registered then the parser will not notify when a function has been found in a piece of code.</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">class </span>EchoAndObserverClass : <span class="keyword">public</span> ClassObserverClass {
 
     <span class="keyword">virtual</span> <span class="keywordtype">void</span> ClassFound(<span class="keyword">const</span> UnicodeString&amp; className, <span class="keyword">const</span> UnicodeString&amp; signature, 
          <span class="keyword">const</span> UnicodeString&amp; comment) {
       printf(<span class="stringliteral">&quot;Found Class %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)className.ToUTF8());
     }
   }
 
   EchoAndObserverClass echoObserver;
   ParserClass parser;
   parser.SetClassObserver(&amp;echoObserver);
   wxString someFileName = wxT(<span class="stringliteral">&quot;/some/file.php&quot;</span>);
   <span class="keywordflow">if</span> (!parser.ScanFile(someFileName)) {
     puts(<span class="stringliteral">&quot;Could not find file to parse!&quot;</span>);
   }
</pre></div><p>Observers follow the PHP parsing rules to the letter. If source code is not valid; then observers may not get called.</p>
<p>Lint functionality</p>
<p>The parser class has the ability to check PHP code for syntax errors. This is done via the LintXXX() methods.</p>
<div class="fragment"><pre class="fragment">   ParserClass parser;
   std::string file = <span class="stringliteral">&quot;/path/to/phpfile.php&quot;</span>;
   LintResultsClass lintResults;
   <span class="keywordflow">if</span> (parser.LintFile(file, parserResults)) {
     printf(<span class="stringliteral">&quot;No syntax errors in file %s&quot;</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span>*)file.c_str());
   }
   <span class="keywordflow">else</span> {
     printf(<span class="stringliteral">&quot;%s. Error found in file %s on line %d.\n&quot;</span>, parserResults.Error, file.c_str(), parserResults.LineNumber);
   }
</pre></div> </div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae5d4647996e516a462eb1f5c3433cbdd"></a><!-- doxytag: member="pelet::ParserClass::GetCharacterPosition" ref="ae5d4647996e516a462eb1f5c3433cbdd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classpelet_1_1ParserClass.html#ae5d4647996e516a462eb1f5c3433cbdd">pelet::ParserClass::GetCharacterPosition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the character position where the parser is currently parsing. This can be called inside an observer callback; in which case the character position is right PAST the current token. </dd></dl>

</div>
</div>
<a class="anchor" id="ace9830c4b9017efb6eaaef8fd967721f"></a><!-- doxytag: member="pelet::ParserClass::LintFile" ref="ace9830c4b9017efb6eaaef8fd967721f" args="(const std::string &amp;file, LintResultsClass &amp;results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpelet_1_1ParserClass.html#ace9830c4b9017efb6eaaef8fd967721f">pelet::ParserClass::LintFile</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform a TRUE PHP syntax check on the entire file. This syntax check is based on PHP 5.3 or PHP 5.4 depending on whether <a class="el" href="classpelet_1_1ParserClass.html#a04891b90521c6be1d2cd27c94df4636e">SetVersion()</a> was called.</p>
<p>Note that this is not entirely the same as 'php -l' command; the PHP lint command detects duplicate function / class names where as this lint check method does not.</p>
<p>Returns true if the file had no syntax errors. Note that a file that does not have any PHP code will be considered a good file (a PHP file that has only HTML is considered good and true will be returned).</p>
<p>This is a convenience method; unicode filenames are not handled.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the file to parse. Must be a full path. </td></tr>
    <tr><td class="paramname">LintResultsClass&amp;</td><td>results any error message will be populated here </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool true if file was found and had no syntax errors. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f47611a12e60ceaa159cf36c4c1230f"></a><!-- doxytag: member="pelet::ParserClass::LintFile" ref="a1f47611a12e60ceaa159cf36c4c1230f" args="(FILE *file, const UnicodeString &amp;filename, LintResultsClass &amp;results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpelet_1_1ParserClass.html#ace9830c4b9017efb6eaaef8fd967721f">pelet::ParserClass::LintFile</a> </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnicodeString &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform a TRUE PHP syntax check on the entire file. This syntax check is based on PHP 5.3 or PHP 5.4 depending on whether <a class="el" href="classpelet_1_1ParserClass.html#a04891b90521c6be1d2cd27c94df4636e">SetVersion()</a> was called.</p>
<p>Note that this is not entirely the same as 'php -l' command; the PHP lint command detects duplicate function / class names where as this lint check method does not.</p>
<p>Returns true if the file had no syntax errors. Note that a file that does not have any PHP code will be considered a good file (a PHP file that has only HTML is considered good and true will be returned).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">FILE*</td><td>file the file to parse. Must be an opened file pointer, this class will NOT own the file pointer </td></tr>
    <tr><td class="paramname">fileName</td><td>this is the name that will be set in results.UnicodeFilename when an error happens </td></tr>
    <tr><td class="paramname">LintResultsClass&amp;</td><td>results any error message will be populated here </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool true if file was found and had no syntax errors. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b522bb72e910d102e90f686f65def41"></a><!-- doxytag: member="pelet::ParserClass::LintString" ref="a9b522bb72e910d102e90f686f65def41" args="(const UnicodeString &amp;code, LintResultsClass &amp;results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpelet_1_1ParserClass.html#a9b522bb72e910d102e90f686f65def41">pelet::ParserClass::LintString</a> </td>
          <td>(</td>
          <td class="paramtype">const UnicodeString &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform a syntax check on the given source code. Source code is assumed to be all code (HTML will not be skipped, and will result in syntax errors). The PHP open tag is optional. Returns true if the code had no syntax errors.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>UnicodeString&amp; code the actual code to parse. </td></tr>
    <tr><td class="paramname">LintResultsClass&amp;</td><td>results any error message will be populated here </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool true if the code has no syntax errors. </dd></dl>

</div>
</div>
<a class="anchor" id="a8cd9079de3a4f9ac07d7eda0575b7e27"></a><!-- doxytag: member="pelet::ParserClass::ParseExpression" ref="a8cd9079de3a4f9ac07d7eda0575b7e27" args="(UnicodeString expressionString, pelet::VariableClass &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpelet_1_1ParserClass.html#a8cd9079de3a4f9ac07d7eda0575b7e27">pelet::ParserClass::ParseExpression</a> </td>
          <td>(</td>
          <td class="paramtype">UnicodeString&#160;</td>
          <td class="paramname"><em>expressionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1VariableClass.html">pelet::VariableClass</a> &amp;&#160;</td>
          <td class="paramname"><em>variable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parses a given PHP expression. This method will parse the given expression into a list of of "chained" calls.</p>
<p>A PHP expression is</p>
<ul>
<li>a variable ($obj)</li>
<li>a function call (myFunc())</li>
<li>an object operation ("$obj-&gt;prop")</li>
<li>a static object operation ("MyClass::Prop")</li>
</ul>
<p>Object operations can be chained; like "$obj-&gt;prop-&gt;anotherFunc()". While indirect variables are allowed in PHP (ie $this-&gt;$prop) this method will not handle them as it is nearly impossible to resolve them at parse time.</p>
<p>The most extreme example is this expression: "$obj-&gt;prop-&gt;anotherFunc()" This method will parse the expression into $obj -&gt;prop -&gt;anotherFunc()</p>
<p>For example, if sourceCode represented this string:</p>
<div class="fragment"><pre class="fragment">     UnicodeString sourceCode = UNICODE_STRING_SIMPLE(<span class="stringliteral">&quot;</span>
<span class="stringliteral">       class UserClass {</span>
<span class="stringliteral">         private $name;</span>
<span class="stringliteral"> </span>
<span class="stringliteral">         function getName() {</span>
<span class="stringliteral">           return $this-&gt;</span>
<span class="stringliteral">     &quot;</span>);
</pre></div><p> then the following C++ code can be used to find a variable's type</p>
<div class="fragment"><pre class="fragment">     ParserClass parser;
     UnicodeString expression = UNICODE_STRING_SIMPLE(<span class="stringliteral">&quot;$this-&gt;&quot;</span>);
     pelet::SymbolClass exprResult;
     <span class="keywordflow">if</span> (parser.ParseExpression(expression, exprResult)) {
        <span class="comment">// if successful, symbol.Lexeme will be set to &quot;$this&quot;</span>
     }
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>the code string of the expression to resolve. This must be the code for a single expression. Examples: $anObject $this-&gt;prop $this-&gt;work()-&gt;another $this-&gt; work()-&gt;another work() self::prop self::prop:: self::func()-&gt;prop parent::prop parent::fun()-&gt;prop aFunction An expression can have whitespace like this $anObject -&gt;method1() -&gt;method2() -&gt;method3()</td></tr>
  </table>
  </dd>
</dl>
<p>A special case that happens when the given expression ends with the object operator: $this-&gt; MyClass:: In this case, the operator will be added the chain list; this way the client code can determine that the variable name actually ended. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">expression</td><td>the expression's name and "chain" list. The properties of this object will be reset every call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade97bfbc6cf913b6a45ba9cde128d327"></a><!-- doxytag: member="pelet::ParserClass::ScanFile" ref="ade97bfbc6cf913b6a45ba9cde128d327" args="(const std::string &amp;file, LintResultsClass &amp;results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpelet_1_1ParserClass.html#ade97bfbc6cf913b6a45ba9cde128d327">pelet::ParserClass::ScanFile</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opens and scans the given file; This function will return once the entire file has been parsed; it will call the proper observers when it encounters a class, function, or variable declaration. This means that this parser should not be modified in the observer calls.</p>
<p>This is a convenience method, it does no handle unicode file names. For that, see ScanFile(FILE*, UnicodeString, LintResultsClass)</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the file to parse. Must be a full path. </td></tr>
    <tr><td class="paramname">LintResultsClass&amp;</td><td>results any error message will be populated here </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool if file was found and could be parsed successfully </dd></dl>

</div>
</div>
<a class="anchor" id="af27f8856c5b45bb97aebb18df35e1e7b"></a><!-- doxytag: member="pelet::ParserClass::ScanFile" ref="af27f8856c5b45bb97aebb18df35e1e7b" args="(FILE *file, const UnicodeString &amp;fileName, LintResultsClass &amp;results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpelet_1_1ParserClass.html#ade97bfbc6cf913b6a45ba9cde128d327">pelet::ParserClass::ScanFile</a> </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnicodeString &amp;&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opens and scans the given file; This function will return once the entire file has been parsed; it will call the proper observers when it encounters a class, function, or variable declaration. This means that this parser should not be modified in the observer calls. This method is given a file pointer, it is useful for example when a file with a unicode filename is opened by the caller.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the file to parse, this class will NOT own the file pointer </td></tr>
    <tr><td class="paramname">fileName</td><td>this is the name that will be set in results.UnicodeFilename when an error happens </td></tr>
    <tr><td class="paramname">LintResultsClass&amp;</td><td>results any error message will be populated here </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool if file was found and could be parsed successfully </dd></dl>

</div>
</div>
<a class="anchor" id="a3e856ab140ed7cd6aacd6bce2fa5b79c"></a><!-- doxytag: member="pelet::ParserClass::ScanString" ref="a3e856ab140ed7cd6aacd6bce2fa5b79c" args="(const UnicodeString &amp;code, LintResultsClass &amp;results)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classpelet_1_1ParserClass.html#a3e856ab140ed7cd6aacd6bce2fa5b79c">pelet::ParserClass::ScanString</a> </td>
          <td>(</td>
          <td class="paramtype">const UnicodeString &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a> &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Scans the given string. This function will return once the entire string has been parsed; it will call the proper observers when it encounters a class, function, or variable declaration. This means that this parser should not be modified in the observer calls.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>UnicodeString&amp; code the code to parse. </td></tr>
    <tr><td class="paramname">LintResultsClass&amp;</td><td>results any error message will be populated here </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool if string could be parsed successfully </dd></dl>

</div>
</div>
<a class="anchor" id="a9ca52d29b89310caa2e2f25412d4304b"></a><!-- doxytag: member="pelet::ParserClass::SetClassMemberObserver" ref="a9ca52d29b89310caa2e2f25412d4304b" args="(ClassMemberObserverClass *observer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpelet_1_1ParserClass.html#a9ca52d29b89310caa2e2f25412d4304b">pelet::ParserClass::SetClassMemberObserver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpelet_1_1ClassMemberObserverClass.html">ClassMemberObserverClass</a> *&#160;</td>
          <td class="paramname"><em>observer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the class member observer. The observer will get notified when a class member is encountered. Memory management of this pointer should be done by the caller.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ClassMemberObserverClass*</td><td>observer the object to sent notifications to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6ad091dd5bb49c73f4fdf5a04b97fd2"></a><!-- doxytag: member="pelet::ParserClass::SetClassObserver" ref="aa6ad091dd5bb49c73f4fdf5a04b97fd2" args="(ClassObserverClass *observer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpelet_1_1ParserClass.html#aa6ad091dd5bb49c73f4fdf5a04b97fd2">pelet::ParserClass::SetClassObserver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpelet_1_1ClassObserverClass.html">ClassObserverClass</a> *&#160;</td>
          <td class="paramname"><em>observer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the class observer. The observer will get notified when a class is encountered. Memory management of this pointer should be done by the caller.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ClassObserverClass*</td><td>observer the object to sent notifications to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4aabf1aeee74f8ddd1b855274cc607c3"></a><!-- doxytag: member="pelet::ParserClass::SetExpressionObserver" ref="a4aabf1aeee74f8ddd1b855274cc607c3" args="(ExpressionObserverClass *expressionObserver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpelet_1_1ParserClass.html#a4aabf1aeee74f8ddd1b855274cc607c3">pelet::ParserClass::SetExpressionObserver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpelet_1_1ExpressionObserverClass.html">ExpressionObserverClass</a> *&#160;</td>
          <td class="paramname"><em>expressionObserver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the expression observer. The observer will get notified when a new expression has been created. Memory management of this pointer should be done by the caller.</p>
<p>There are performance implications if you call this method; if you want to be notified of expressions then the full PHP parser is used; and parsing a file can be memory intensive.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ExpressionObserverClass*</td><td>observer the object to sent notifications to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a3418882ddc19eb974728ead1e66ec6"></a><!-- doxytag: member="pelet::ParserClass::SetFunctionObserver" ref="a6a3418882ddc19eb974728ead1e66ec6" args="(FunctionObserverClass *observer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpelet_1_1ParserClass.html#a6a3418882ddc19eb974728ead1e66ec6">pelet::ParserClass::SetFunctionObserver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpelet_1_1FunctionObserverClass.html">FunctionObserverClass</a> *&#160;</td>
          <td class="paramname"><em>observer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the function observer. The observer will get notified when a function is encountered. Memory management of this pointer should be done by the caller.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">FunctionObserverClass*</td><td>observer the object to sent notifications to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b84fa65457694a1b966ce30ea956882"></a><!-- doxytag: member="pelet::ParserClass::SetVariableObserver" ref="a9b84fa65457694a1b966ce30ea956882" args="(VariableObserverClass *observer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpelet_1_1ParserClass.html#a9b84fa65457694a1b966ce30ea956882">pelet::ParserClass::SetVariableObserver</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpelet_1_1VariableObserverClass.html">VariableObserverClass</a> *&#160;</td>
          <td class="paramname"><em>observer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the variable observer. The observer will get notified when a new variable has been created. Memory management of this pointer should be done by the caller.</p>
<p>There are performance implications if you call this method; if you want to be notified of variables then the full PHP parser is used; and parsing a file can be memory intensive.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">VariableObserverClass*</td><td>observer the object to sent notifications to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04891b90521c6be1d2cd27c94df4636e"></a><!-- doxytag: member="pelet::ParserClass::SetVersion" ref="a04891b90521c6be1d2cd27c94df4636e" args="(Versions version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classpelet_1_1ParserClass.html#a04891b90521c6be1d2cd27c94df4636e">pelet::ParserClass::SetVersion</a> </td>
          <td>(</td>
          <td class="paramtype">Versions&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the version that this parser can handle. This needs to be called BEFORE <a class="el" href="classpelet_1_1ParserClass.html#ade97bfbc6cf913b6a45ba9cde128d327">ScanFile()</a> or <a class="el" href="classpelet_1_1ParserClass.html#a3e856ab140ed7cd6aacd6bce2fa5b79c">ScanString()</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/pelet/<a class="el" href="ParserClass_8h_source.html">ParserClass.h</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 30 2014 22:21:46 for pelet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
