/*
 * This software is released under the terms of the MIT License
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * @copyright  2009-2012 Roberto Perpuly
 * @license    http://www.opensource.org/licenses/mit-license.php The MIT License
 */
#ifndef __parserclass__
#define __parserclass__

#include <pelet/LexicalAnalyzerClass.h>
#include <pelet/TokenClass.h>
#include <pelet/ParserObserverClass.h>
#include <unicode/unistr.h>
#include <pelet/Api.h>

/**
\mainpage pelet: Php Easy LanguagE Toolkit. A C++ library for analyzing PHP source code
\section Overview
This doc briefly describes the major design of the pelet parser library.

pelet has the folowing major components:

- Parser
- Lexer
- Parser Implementation

\section Parser
The pelet::ParserClass, along with pelet::ClassObserverClass, pelet::ClassMemberObserverClass, 
pelet::FunctionObserverClass, pelet::VariableObserverClass, and pelet::ExpressionObserverClass, make up
the "driver" (or main entry point) to pelet. ParserClass takes as input a string (or file) of PHP source code and 
extracts artifacts from it (classes, functions, methods, etc..).

To use the parser, a user will create a class that defines the callbacks for each PHP artifact (class, function,
method, etc). The user will register these callbacks with the parser. When pelet::ParserClass::ScanFile is called, 
the bison parser rules start looking for syntax rules. The parser will ask the lexer for tokens.  As soon as a 
specific rule is hit, then the proper parser observer callback gets called. For example, when the parser hits 
the "class" rule (ie "class MyClass {") then the class observer will get called; and the observer will get the 
identifer ("MyClass") along with other info (signature, comment).

The important thing to note here is that the callbacks happen while ParserClass::ScanFile still has control.
ParserClass::ScanFile does not return control until the entire file has been parsed; multiple callbacks will have
been called before ParserClass::ScanFile returns.  For this reason, it is important that ParserClass::ScanFile
should not be called within any of the observers.

A word on concurrency: The pelet parser does not keep global state (it is a "pure" bison parser), but the pelet
parser is not thread-safe.  If pelet is used on a multi-threaded app, each thread should have its own instance
of pelet::ParserClass.

\section Lexer 
The pelet::LexicalAnalyzerClass is used to tokenize the source code (turn strings into tokens). The
details of the implementation can be found in the \ref LexerDetailsPage page.

\section ParserImplementation Parser Implementation
This is a parser generated with the help of Bison. This used to follow the PHP rules; 
for example after "function" comes the function name; after "if" comes a "(" and so on...)
When the syntax rules hit an artifact (for example a class) the syntax rules will call the proper observer.
The details of the implementation can be found in the \ref ParserImplementationDetailsPage page.
*/
namespace pelet {

/**
 * Holds the results of the lint check.  Currently lint check will stop when 
 * the first error is encountered.
 */
class PELET_API LintResultsClass {
public:

	/**
	 * A short description of the error; this is generated by the bison parser and is
	 * not the most user-friendly but it is exactly what PHP displays; might as well
	 * keep it consistant.
	 */
	UnicodeString Error;

	/**
	 * Path to the file in which the error ocurred. 
	 * This is what was given to the LintFile() method.
	 * For LintString() results this will be the empty string.
	 */
	std::string File;

	/**
	 * The line in which the error ocurred. This is 1-based.
	 */
	int LineNumber;

	/**
	 * The character offset in which the error ocurred (with regargs to the start of
	 * the file). This is 0-based.
	 */
	int CharacterPosition;

	LintResultsClass();

	/**
	 * copy the attributes from src to this object.
	 */
	void Copy(const LintResultsClass& src);
	
	/**
	 * remove any error string
	 */
	void Clear();
};

/**
 * The parser class is designed in a way that can utilized by different pieces of code.  The parser will analyze
 * given code and make calls to the different registered observers.  There are observers for classes, functions, and 
 * methods. Not all observers have to be set; for example if a FunctionObserverClass is never registered then the 
 * parser will not notify when a function has been found in a piece of code.
 * 
 * @code
 *   class EchoAndObserverClass : public ClassObserverClass {
 * 
 *     virtual void ClassFound(const UnicodeString& className, const UnicodeString& signature, 
 *          const UnicodeString& comment) {
 *       printf("Found Class %s\n", (const char*)className.ToUTF8());
 *     }
 *   }
 * 
 *   EchoAndObserverClass echoObserver;
 *   ParserClass parser;
 *   parser.SetClassObserver(&echoObserver);
 *   wxString someFileName = wxT("/some/file.php");
 *   if (!parser.ScanFile(someFileName)) {
 *     puts("Could not find file to parse!");
 *   }
 * @endcode
 * 
 * Observers follow the PHP parsing rules to the letter.  If source code is not valid; then observers may not
 * get called.
 *
 * Lint functionality
 * 
 * The parser class has the ability to check PHP code for syntax errors. This is done via the Lint() method.
 * 
 * @code
 *   ParserClass parser;
 *   std::string file = "/path/to/phpfile.php";
 *   LintResultsClass lintResults;
 *   if (parser.LintFile(file, parserResults)) {
 *     printf("No syntax errors in file %s", (const char*)file.c_str());
 *   }
 *   else {
 *     printf("%s. Error found in file %s on line %d.\n", parserResults.Error, file.c_str(), parserResults.LineNumber);
 *   }
 * @endcode
 */
class PELET_API ParserClass {


public:
	
	ParserClass();
	
	/**
	 * Opens and scans the given file; This function will return once the entire
	 * file has been parsed; it will call the proper observers when it encounters
	 * a class, function, or variable declaration. This means that this
	 * parser should not be modified in the observer calls.
	 * 
	 * @param file the file to parse.  Must be a full path.
	 * @param LintResultsClass& results any error message will be populated here
	 * @return bool if file was found and could be parsed successfully
	 */
	bool ScanFile(const std::string& file, LintResultsClass& results);
	
	/**
	 * Scans the given string. This function will return once the entire
	 * string has been parsed; it will call the proper observers when it encounters
	 * a class, function, or variable declaration. This means that this
	 * parser should not be modified in the observer calls.
	 * 
	 * @param const UnicodeString& code the code to parse.
	 * @param LintResultsClass& results any error message will be populated here
	 * @return bool if string could be parsed successfully
	 */
	bool ScanString(const UnicodeString& code, LintResultsClass& results);
	
	/**
	 * Set the class observer.  The observer will get notified when a class is encountered.
	 * Memory management of this pointer should be done by the caller.
	 * 
	 * @param ClassObserverClass* observer the object to sent notifications to 
	 */
	void SetClassObserver(ClassObserverClass* observer);
	
	/**
	 * Set the class member observer.  The observer will get notified when a class member is encountered.
	 * Memory management of this pointer should be done by the caller.
	 * 
	 * @param ClassMemberObserverClass* observer the object to sent notifications to 
	 */
	void SetClassMemberObserver(ClassMemberObserverClass* observer);
	
	/**
	 * Set the function observer.  The observer will get notified when a function is encountered.
	 * Memory management of this pointer should be done by the caller.
	 * 
	 * @param FunctionObserverClass* observer the object to sent notifications to 
	 */
	void SetFunctionObserver(FunctionObserverClass* observer);
	
	/**
	 * Set the variable observer.  The observer will get notified when a new variable has been created.
	 * Memory management of this pointer should be done by the caller.
	 * 
	 * @param VariableObserverClass* observer the object to sent notifications to 
	 */
	void SetVariableObserver(VariableObserverClass* observer);
	
	/**
	 * Set the expression observer.  The observer will get notified when a new expression has been created.
	 * Memory management of this pointer should be done by the caller.
	 * 
	 * @param ExpressionObserverClass* observer the object to sent notifications to 
	 */
	void SetExpressionObserver(ExpressionObserverClass* expressionObserver);
	
	/**
	 * Perform a TRUE PHP syntax check on the entire file. This syntax check is based on PHP 5.3.
	 * Note that this is not entirely the same as 'php -l' command; the PHP lint command detects 
	 * duplicate function  / class names where as this lint check method does not.
	 *
	 * Returns true if the file had no syntax errors. Note that a file that does not have
	 * any PHP code will be considered a good file (a PHP file that has only HTML is
	 * considered good and true will be returned).
	 * 
	 * @param file the file to parse.  Must be a full path.
	 * @param LintResultsClass& results any error message will be populated here
	 * @return bool true if file was found and had no syntax errors.
	 */
	bool LintFile(const std::string& file, LintResultsClass& results);
	
	/**
	 * Perform a syntax check on the given source code. Source code is assumed to be
	 * all code (HTML will not be skipped, and will result in syntax errors). The PHP 
	 * open tag is optional.
	 * Returns true if the code had no syntax errors.
	 * 
	 * @param const UnicodeString& code the actual code to parse.
	 * @param LintResultsClass& results any error message will be populated here
	 * @return bool true if the code has no syntax errors.
	 */
	bool LintString(const UnicodeString& code, LintResultsClass& results);

	/**
	 * @return the character position where the parser is currently parsing. This can be called
	 * inside an observer callback; in which case the character position is right PAST the
	 * current token.
	 */
	int GetCharacterPosition() const;

	
	/**
	 * Parses a given PHP expression.  This method will parse the given expression into a list of
	 * of "chained" calls.
	 *
	 * A PHP expression is  
	 *  - a variable  ($obj)
	 *  - a function call (myFunc())
	 *  - an object operation ("$obj->prop")
	 *  - a static object operation ("MyClass::Prop")
	 * 
	 * Object operations can be chained; like "$obj->prop->anotherFunc()". While indirect variables are allowed
	 * in PHP (ie $this->$prop)  this method will not handle them as it is nearly impossible to resolve them at parse time.
	 *
	 * The most extreme example is this expression: "$obj->prop->anotherFunc()"
	 * This method will parse the expression into
	 * $obj
	 * ->prop
	 * ->anotherFunc()

	 * For example, if sourceCode represented this string:
	 * 
	 *   @code
	 *     UnicodeString sourceCode = UNICODE_STRING_SIMPLE("
	 *       class UserClass {
	 *         private $name;
	 * 
	 *         function getName() {
	 *           return $this->
	 *     ");
	 *   @endcode
	 *  then the following C++ code can be used to find a variable's type
	 * 
	 *   @code
	 *     ParserClass parser;
	 *     UnicodeString expression = UNICODE_STRING_SIMPLE("$this->");
	 *     pelet::SymbolClass exprResult;
	 *     if (parser.ParseExpression(expression, exprResult)) {
	 *     	// if successful, symbol.Lexeme will be set to "$this"
	 *     }
	 *   @endcode
	 * 
	 * 
	 * @param expression the code string of the expression to resolve. This must be the code for a single expression.
	 *        Examples:
	 *        $anObject
	 *        $this->prop
	 *        $this->work()->another
	 *        $this->
	 *		  work()->another
	 *		  work()
	 *        self::prop
	 *        self::prop::
	 *        self::func()->prop
	 *        parent::prop
	 *        parent::fun()->prop
	 *        aFunction
	 *        An expression can have whitespace like this
	 *        $anObject
	 *			->method1()
	 *			->method2()
	 *			->method3()
	 *
	 * A special case that happens when the given expression ends with the object operator:
	 *        $this->
	 *        MyClass::
	 * In this case, the operator will be added the chain list; this way the client code can determine that
	 * the variable name actually ended.
	 * @param symbol the expression's name and "chain" list. The  properties of this object will be reset every call.
	 */
	void ParseExpression(UnicodeString expression, SymbolClass& symbol);
	
private:

	/**
	 * Clean up any resources after parsing a file. This is also very important if the 
	 * parser opens a string; without closing the string will not be released (if it's a
	 * long string).
	 */
	void Close();

	/**
	 * Used to tokenize code
	 */
	LexicalAnalyzerClass Lexer;
	
	/**
	 * Notify the ClassObserver when a class has been found. Memory management of this pointer should be
	 * done by the caller.
	 */
	ClassObserverClass* ClassObserver;

	/**
	 * Notify the ClassMemberObserver when a class member has been found. Memory management of this pointer should be
	 * done by the caller.
	 */
	ClassMemberObserverClass* ClassMemberObserver;
	
	/**
	 * Notify the FunctionObserver when a function has been found. Memory management of this pointer should be
	 * done by the caller.
	 */	
	FunctionObserverClass* FunctionObserver;
	
	/**
	 * Notify the VariableObserver when a variable has been created. Memory management of this pointer should be
	 * done by the caller.
	 */		
	VariableObserverClass* VariableObserver;
	
	
	/**
	 * Notify the ExpressionObserver when an expressionhas been found. Memory management of this pointer should be
	 * done by the caller.
	 */		
	ExpressionObserverClass* ExpressionObserver;
};



}
#endif // __parserclass__
