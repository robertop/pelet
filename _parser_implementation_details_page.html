<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>pelet: Parser Implementation Details</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">pelet
   
   </div>
   <div id="projectbrief">Php Easy LanguagE Toolkit. A C++ library for analyzing PHP source code</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_parser_implementation_details_page.html','');
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Parser Implementation Details </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>pelet uses a Bison parser to validate PHP syntax rules. Knowledge of the bison parser generator is required to modify the parser code. You may look at the bison manual at <a href="http://www.gnu.org/software/bison/manual/">http://www.gnu.org/software/bison/manual/</a></p>
<p>First thing to note is that the pelet grammar file (Php53ParserImpl.y) was created by gutting the grammar file that comes in the PHP source distribution. If you already know the PHP grammar file then you will be familiar with the grammar. If not, continue reading this to get a better understanding.</p>
<p>Bison is a parser generator; we write rules in bison grammar, run the grammar through the bison executable, and the executable generates C++ source code that can be used in any program. The generated C++ source code will define a function called php53parse() that we can then call from anywhere in our program.</p>
<h2><a class="anchor" id="ParserImplementationDetailsInput"></a>
Input</h2>
<p>We define the inputs to the php53parse function by using the parse-param directive, this will make it so that the php53parse and the php53lex functionx accept a <a class="el" href="classpelet_1_1_lexical_analyzer_class.html">pelet::LexicalAnalyzerClass</a> as an argument. We define a php53lex function, and in that function we will use <a class="el" href="classpelet_1_1_lexical_analyzer_class.html#a31dc346a9e8e8302130439e86433fc22">pelet::LexicalAnalyzerClass::NextToken</a> to get the next token from the source code being parsed.</p>
<h2><a class="anchor" id="ParserImplementationDetailsGrammar"></a>
Grammar rules</h2>
<p>Let's look at an example grammar rule. A (simplified) bison grammar rule for a PHP variable looks like this:</p>
<div class="fragment"><pre class="fragment">compound_variable:
                T_VARIABLE                      { observers.CurrentExpressionPushAsVariable($1); }
        |       <span class="charliteral">&#39;$&#39;</span> <span class="charliteral">&#39;{&#39;</span> expr <span class="charliteral">&#39;}&#39;</span> 
;
</pre></div><p>Where compound_variable is the name of a rule T_VARIABLE is token that matches the rule | is the symbol to say that rule can match another set of tokens '$' {' expr '}' is a "nonterminal" rule (rule that is made up of another rule)</p>
<p>This rule will match a T_VARIABLE token (from the lexer) or a "$" followed by a "{" that is followed by an expr rule that is followed by another "}".</p>
<p>Each rule can have an action associated with it. An action is just a block of C / C++ code that is executed when the rule is matched. The only addition is that the action can access the matching tokens by using $1 for the first token, $2 for the second token, and so on... For example, in the second branch $4 is the token '}'</p>
<p>So just what type is $1 ? The $n variables are of type YYSTYPE, in our case we define it to be <a class="el" href="classpelet_1_1_semantic_value_class.html">pelet::SemanticValueClass</a> (see the php53lex() function). This allows us to get the token, but also the lexeme, where token is the numeric representation, for example T_VARIABLE, and the lexeme is the textual representation (for example "$userName").</p>
<p>What about the tokens from recursive rules, as in "expr" in the case above? Bison allows a rule to return a YYSTYPE back to a calling rule by using the $$ pseudo variable, but in our case this is rarely used, and this means that rules should NOT access tokens from sub-rules. Attempting to access variables from sub-rules will result in program crashes.</p>
<p>The grammar file contains the entire PHP grammar; most of the rules don't have actions because we are not interested in them; but the ones we are interested in have actions. In our case, we delegate most of the work to the <a class="el" href="classpelet_1_1_observer_quad_class.html">pelet::ObserverQuadClass</a> and the rules contain just 1-liner method calls. This makes the code a bit more IDE-friendly.</p>
<h2><a class="anchor" id="ParserImplementationDetailsObserver"></a>
Observer Quad</h2>
<p>An <a class="el" href="classpelet_1_1_observer_quad_class.html">ObserverQuadClass</a> is an object that holds the observers (the objects that want to be notified of source code artifacts like classes, functions, etc..). It gets passed in as a parameter to the php53parse and the php53lex functions just like the lexer. The different methods of the ObserverQuad get called as the different bison rules are triggered, as in for example the "class" rule:</p>
<div class="fragment"><pre class="fragment">unticked_class_declaration_statement:
                class_entry_type T_STRING                       { observers.ClassSetName($2); }
                extends_from implements_list            { observers.ClassFound(analyzer.GetLineNumber()); }
                <span class="charliteral">&#39;{&#39;</span> class_statement_list <span class="charliteral">&#39;}&#39;</span>            { observers.ClassEnd(analyzer.GetLineNumber()); }

class_entry_type:
                T_CLASS                                 { observers.ClassStart($1, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>); }
        |       T_ABSTRACT T_CLASS              { observers.ClassStart($1, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>); }
        |       T_FINAL T_CLASS                 { observers.ClassStart($1, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>); }
;
</pre></div><p>In this case, when we see T_CLASS (class keyword) the ClassStart method gets called. Then, the ClassSetName method gets called (which allows us to get the name of the class). Then, after any extends or implements keywords rules are parsed we call the ClassFound method. The ClassFound method will, in turn, call any <a class="el" href="classpelet_1_1_class_observer_class.html">pelet::ClassObserverClass</a> instances that it has been given.</p>
<h2><a class="anchor" id="ParserImplementationDetailsUpdatingGrammar"></a>
Updating the grammar</h2>
<p>When a new PHP version updates the grammar; we must update the rules. The simplest way to do this would be to diff the PHP grammar file with its prior versions, taking the new rules, gutting them (removing the action block), and adding them to Php53ParserImpl.y. If any new artifacts become available, then we should create new methods in the <a class="el" href="classpelet_1_1_observer_quad_class.html">ObserverQuadClass</a>, and possibly new interfaces that will expose the new artifacts to the users of the pelet library. </p>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Fri Mar 30 2012 17:45:55 for pelet by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.0 </li>
   </ul>
 </div>


</body>
</html>
