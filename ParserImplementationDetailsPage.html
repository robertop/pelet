<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>pelet: Parser Implementation Details</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">pelet
   
   </div>
   <div id="projectbrief">Php Easy LanguagE Toolkit. A C++ library for analyzing PHP source code</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Parser Implementation Details </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>pelet uses a Bison parser to validate PHP syntax rules. Knowledge of the bison parser generator is required to modify the parser code. You may look at the bison manual at <a href="http://www.gnu.org/software/bison/manual/">http://www.gnu.org/software/bison/manual/</a></p>
<p>First thing to note is that the pelet grammar file (Php53ParserImpl.y) was created by gutting the grammar file that comes in the PHP source distribution. If you already know the PHP grammar file then you will be familiar with the grammar. If not, continue reading this to get a better understanding.</p>
<p>Bison is a parser generator; we write rules in bison grammar, run the grammar through the bison executable, and the executable generates C++ source code that can be used in any program. The generated C++ source code will define a function called php53parse() that we can then call from anywhere in our program.</p>
<h2><a class="anchor" id="ParserImplementationDetailsInput"></a>
Input</h2>
<p>We define the inputs to the php53parse function by using the parse-param directive, this will make it so that the php53parse and the php53lex functions accept a <a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> as an argument. We define a php53lex function, and in that function we will use <a class="el" href="classpelet_1_1LexicalAnalyzerClass.html#a31dc346a9e8e8302130439e86433fc22">pelet::LexicalAnalyzerClass::NextToken</a> to get the next token from the source code being parsed.</p>
<h2><a class="anchor" id="ParserImplementationDetailsGrammar"></a>
Grammar rules</h2>
<p>Let's look at an example grammar rule. A (simplified) bison grammar rule for a PHP variable looks like this:</p>
<div class="fragment"><pre class="fragment">compound_variable:
                T_VARIABLE                      { $$ = observers.ExpressionMakeVariable($1); }
        |       <span class="charliteral">&#39;$&#39;</span> <span class="charliteral">&#39;{&#39;</span> expr <span class="charliteral">&#39;}&#39;</span> 
;
</pre></div><p>Where compound_variable is the name of a rule T_VARIABLE is token that matches the rule. By convention these are upper case | is the symbol to say that rule can match another set of tokens '$' {' '}' are constant tokens to match on expr is a "nonterminal" rule (rule that is made up of another rule). By convention these are lower case.</p>
<p>This rule will match a T_VARIABLE token (from the lexer) or a "$" followed by a "{" that is followed by an expr rule that is followed by another "}".</p>
<p>Each rule can have an action associated with it. An action is just a block of C / C++ code that is executed when the rule is matched. The only addition is that the action can access the matching tokens by using $1 for the first token, $2 for the second token, and so on... For example, in the second branch $4 is the token '}'</p>
<p>So just what type is $1 ? The type of the $n variables is controlled via bison type declarations. Each bison type declaration declares what each rule will "return" ie. which member of the YYSTYPE union it will write to. In our case we define it to be a union <a class="el" href="namespacepelet.html#a28f4ac5c84bc263188edfc784ae4a106">pelet::ParserTypeClass</a>. The <a class="el" href="unionpelet_1_1ParserType.html">ParserType</a> is a union of all possible data structures that we build to create the AST from the source code. For example, the grammar rule "expr" has the following type declaration</p>
<p>type &lt;expression&gt; expr</p>
<p>At the most simple case, tokens (ie. T_VARIABLE) are of type <a class="el" href="classpelet_1_1SemanticValueClass.html">pelet::SemanticValueClass</a>; this allows us to get the token, but also the lexeme; the token is the numeric representation, for example T_VARIABLE, and the lexeme is the textual representation (for example "$userName"). All non-terminals have a type declaration and that declaration dictates what type the rule will return (using the $$ pseudo variable is essentially accessing the declared property of the union). For example, the expr rule will end up assigning a value to the expression property of the <a class="el" href="unionpelet_1_1ParserType.html">ParserType</a> union. Since the expression property is declared to be of type <a class="el" href="classpelet_1_1ExpressionClass.html">pelet::ExpressionClass</a>*, then in our example from above $3 (expr) is of type <a class="el" href="classpelet_1_1ExpressionClass.html">pelet::ExpressionClass</a>*.</p>
<p>The AST is built-up by the recursive defintion of the statement grammar rule. Simplified version of the statement grammar rule is this:</p>
<p>top_statement_list: top_statement_list top_statement { $$ = observers.StatementListMerge($1, $2); } | / * empty * / { $$ = observers.StatementListMake(); } ;</p>
<p>top_statement: statement { $$ = $1; }</p>
<p>A top_statement_list is made up a sub list plus a statement; in the action the results top_statement are added to the sub list and the new list is returned.</p>
<p>The grammar file contains the entire PHP grammar; most of the rules don't have actions because we are not interested in them; but the ones we are interested in have actions. In our case, we delegate most of the work to the <a class="el" href="classpelet_1_1FullParserObserverClass.html">pelet::FullParserObserverClass</a> and the rules contain just 1-liner method calls. This makes the code a bit more IDE-friendly. Another reason - a very important one - that the grammar file and ParserObserverClass are designed this way is to make it easy to implement the PHP syntax correctly. Since there is no official PHP language specification, the only sure way to know that we implemented the PHP syntax correctly is to use the actual PHP grammar file.</p>
<h2><a class="anchor" id="ParserImplementationDetailsObserver"></a>
Observer Quad</h2>
<p>An <a class="el" href="classpelet_1_1FullParserObserverClass.html">FullParserObserverClass</a> is an object that holds the observers (the objects that want to be notified of source code artifacts like classes, functions, etc..). It gets passed in as a parameter to the php53parse and the php53lex functions just like the lexer. The different methods of the ObserverQuad get called as the different bison rules are triggered, as in for example the "class" rule:</p>
<div class="fragment"><pre class="fragment">unticked_class_declaration_statement:
                class_entry_type T_STRING                       
                extends_from implements_list            { observers.SetCurrentClassName($2); }  
                <span class="charliteral">&#39;{&#39;</span> class_statement_list <span class="charliteral">&#39;}&#39;</span>            { $$ = observers.ClassSymbolMake($2, $1, $3, $4, $8);
                                                                                          observers.StatementListMerge($$, $7); 
                                                                                          observers.SetCurrentClassName(NULL);  
                                                                                        }

class_entry_type:
                T_CLASS                                 { $$ = observers.ClassSymbolStart($1, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>); }
        |       T_ABSTRACT T_CLASS              { $$ = observers.ClassSymbolStart($1, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>); }
        |       T_FINAL T_CLASS                 { $$ = observers.ClassSymbolStart($1, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>); }
;
</pre></div><p>In this case, when we see T_CLASS (class keyword) the ClassSymbolStart method gets called. Then, the SetCurrentClassName method gets called (which allows us to get the name of the class). Then, after any extends or implements keywords rules are parsed create a <a class="el" href="classpelet_1_1ClassSymbolClass.html">ClassSymbolClass</a> structure. By assigning it to $$, the calling rule will take the resulting object and store it in a <a class="el" href="classpelet_1_1StatementListClass.html">StatementListClass</a> object.</p>
<h2><a class="anchor" id="ParserImplementationDetailsUpdatingGrammar"></a>
Updating the grammar</h2>
<p>When a new PHP version updates the grammar; we must update the rules. The simplest way to do this would be to diff the PHP grammar file with its prior versions, taking the new rules, gutting them (removing the action block), and adding them to Php53ParserImpl.y. If any new artifacts become available, then we should create new methods in the <a class="el" href="classpelet_1_1FullParserObserverClass.html">FullParserObserverClass</a>, and possibly new interfaces that will expose the new artifacts to the users of the pelet library.</p>
<h2><a class="anchor" id="Multiple"></a>
Parser implementations</h2>
<p>pelet has three different parsers for each PHP version; a lint parser, a resource parser, and a full parser.</p>
<p>The lint parser is the quickest parser but it does not gather any info; its only purpose is to check whether a piece of source code is valid PHP code. These are defined in Php53LintParser.cpp and Php54LintParser.cpp.</p>
<p>The resource parser is not as quick, but it gathers class, method, function, traits, and defined constants info (does not gather local variables or function calls). These are defined in Php53ResourceParser.cpp and Php54ResourceParser.cpp.</p>
<p>The full parser is the slowest, but it gathers all expressions; including local variables and function calls. These are defined in Php53FullParser.cpp and Php54FullParser.cpp. </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 30 2014 22:08:58 for pelet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
