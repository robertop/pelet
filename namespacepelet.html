<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>pelet: pelet Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">pelet
   
   </div>
   <div id="projectbrief">Php Easy LanguagE Toolkit. A C++ library for analyzing PHP source code</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pelet Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1FullParserObserverClass.html">FullParserObserverClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1LanguageDiscoveryClass.html">LanguageDiscoveryClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">LexicalAnalyzerClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1LintResultsClass.html">LintResultsClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParserClass.html">ParserClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1UnicodeStringComparatorClass.html">UnicodeStringComparatorClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ClassObserverClass.html">ClassObserverClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ClassMemberObserverClass.html">ClassMemberObserverClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1FunctionObserverClass.html">FunctionObserverClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1VariableObserverClass.html">VariableObserverClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ExpressionObserverClass.html">ExpressionObserverClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ScopeClass.html">ScopeClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1AstItemClass.html">AstItemClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1StatementClass.html">StatementClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1QualifiedNameClass.html">QualifiedNameClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1VariablePropertyClass.html">VariablePropertyClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ExpressionClass.html">ExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ScalarExpressionClass.html">ScalarExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ArrayPairExpressionClass.html">ArrayPairExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ArrayExpressionClass.html">ArrayExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1NewInstanceExpressionClass.html">NewInstanceExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1VariableClass.html">VariableClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1StatementListClass.html">StatementListClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ConstantStatementClass.html">ConstantStatementClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1NamespaceDeclarationClass.html">NamespaceDeclarationClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1NamespaceUseClass.html">NamespaceUseClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1TraitUseClass.html">TraitUseClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1TraitAliasClass.html">TraitAliasClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1TraitInsteadOfClass.html">TraitInsteadOfClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1AssignmentExpressionClass.html">AssignmentExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1AssignmentListExpressionClass.html">AssignmentListExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1AssignmentCompoundExpressionClass.html">AssignmentCompoundExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1BinaryOperationClass.html">BinaryOperationClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1UnaryOperationClass.html">UnaryOperationClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1UnaryVariableOperationClass.html">UnaryVariableOperationClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1TernaryOperationClass.html">TernaryOperationClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ClosureExpressionClass.html">ClosureExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1IssetExpressionClass.html">IssetExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1EvalExpressionClass.html">EvalExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1GlobalVariableStatementClass.html">GlobalVariableStatementClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1StaticVariableStatementClass.html">StaticVariableStatementClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1TokenPositionClass.html">TokenPositionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1SemanticValueClass.html">SemanticValueClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ClassSymbolClass.html">ClassSymbolClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ParametersListClass.html">ParametersListClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ClassMemberSymbolClass.html">ClassMemberSymbolClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1IncludeExpressionClass.html">IncludeExpressionClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionpelet_1_1ParserType.html">ParserType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1ResourceParserObserverClass.html">ResourceParserObserverClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionpelet_1_1ResourceParserType.html">ResourceParserType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1TokenClass.html">TokenClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1BufferClass.html">BufferClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1UCharBufferedFileClass.html">UCharBufferedFileClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpelet_1_1UCharBufferClass.html">UCharBufferClass</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="unionpelet_1_1ParserType.html">pelet::ParserType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#a28f4ac5c84bc263188edfc784ae4a106">ParserTypeClass</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef union <br class="typebreak"/>
<a class="el" href="unionpelet_1_1ResourceParserType.html">pelet::ResourceParserType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#a637f7e5f150b98510952ff25157159e6">ResourceParserTypeClass</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#a2f19d390f08da8ac1d5fd8125f412429">Tokens</a> { <br/>
&#160;&#160;<b>T_ERROR_UNTERMINATED_COMMENT</b> =  -1, 
<b>T_ERROR_UNTERMINATED_STRING</b> =  -2, 
<b>T_ERROR_UNTERMINATED_BACKTICK</b> =  -3, 
<a class="el" href="namespacepelet.html#a2f19d390f08da8ac1d5fd8125f412429a70047db2eb71ae6a6cdf07e4d8cd568d">T_END</a> =  0, 
<br/>
&#160;&#160;<b>T_ABSTRACT</b> =  502, 
<b>T_AND_EQUAL</b> =  503, 
<b>T_ARRAY</b> =  504, 
<b>T_ARRAY_CAST</b> =  505, 
<br/>
&#160;&#160;<b>T_AS</b> =  506, 
<b>T_BAD_CHARACTER</b> =  507, 
<b>T_BOOL_CAST</b> =  508, 
<b>T_BOOLEAN_AND</b> =  509, 
<br/>
&#160;&#160;<b>T_BOOLEAN_OR</b> =  510, 
<b>T_BREAK</b> =  511, 
<b>T_CALLABLE</b> =  512, 
<b>T_CASE</b> =  513, 
<br/>
&#160;&#160;<b>T_CATCH</b> =  514, 
<b>T_CHARACTER</b> =  515, 
<b>T_CLASS</b> =  516, 
<b>T_CLASS_C</b> =  517, 
<br/>
&#160;&#160;<b>T_CLONE</b> =  518, 
<b>T_CLOSE_TAG</b> =  519, 
<b>T_COMMENT</b> =  520, 
<b>T_CONCAT_EQUAL</b> =  521, 
<br/>
&#160;&#160;<b>T_CONST</b> =  522, 
<b>T_CONSTANT_ENCAPSED_STRING</b> =  523, 
<b>T_CONTINUE</b> =  524, 
<b>T_CURLY_OPEN</b> =  525, 
<br/>
&#160;&#160;<b>T_DEC</b> =  526, 
<b>T_DECLARE</b> =  527, 
<b>T_DEFAULT</b> =  528, 
<b>T_DIR</b> =  529, 
<br/>
&#160;&#160;<b>T_DIV_EQUAL</b> =  530, 
<b>T_DNUMBER</b> =  531, 
<b>T_DO</b> =  532, 
<b>T_DOC_COMMENT</b> =  533, 
<br/>
&#160;&#160;<b>T_DOLLAR_OPEN_CURLY_BRACES</b> =  534, 
<b>T_DOUBLE_ARROW</b> =  535, 
<b>T_DOUBLE_CAST</b> =  536, 
<b>T_ECHO</b> =  537, 
<br/>
&#160;&#160;<b>T_ELSE</b> =  538, 
<b>T_ELSEIF</b> =  539, 
<b>T_EMPTY</b> =  540, 
<b>T_ENCAPSED_AND_WHITESPACE</b> =  541, 
<br/>
&#160;&#160;<b>T_ENDDECLARE</b> =  542, 
<b>T_ENDFOR</b> =  543, 
<b>T_ENDFOREACH</b> =  544, 
<b>T_END_HEREDOC</b> =  545, 
<br/>
&#160;&#160;<b>T_ENDIF</b> =  546, 
<b>T_ENDSWITCH</b> =  547, 
<b>T_ENDWHILE</b> =  548, 
<b>T_EVAL</b> =  549, 
<br/>
&#160;&#160;<b>T_EXIT</b> =  550, 
<b>T_EXTENDS</b> =  551, 
<b>T_FILE</b> =  552, 
<b>T_FINAL</b> =  553, 
<br/>
&#160;&#160;<b>T_FOR</b> =  554, 
<b>T_FOREACH</b> =  555, 
<b>T_FUNC_C</b> =  556, 
<b>T_FUNCTION</b> =  557, 
<br/>
&#160;&#160;<b>T_GLOBAL</b> =  558, 
<b>T_GOTO</b> =  559, 
<b>T_HALT_COMPILER</b> =  560, 
<b>T_IF</b> =  561, 
<br/>
&#160;&#160;<b>T_IMPLEMENTS</b> =  562, 
<b>T_INC</b> =  563, 
<b>T_INCLUDE</b> =  564, 
<b>T_INCLUDE_ONCE</b> =  565, 
<br/>
&#160;&#160;<b>T_INLINE_HTML</b> =  566, 
<b>T_INSTANCEOF</b> =  567, 
<b>T_INSTEADOF</b> =  568, 
<b>T_INT_CAST</b> =  569, 
<br/>
&#160;&#160;<b>T_INTERFACE</b> =  570, 
<b>T_IS_EQUAL</b> =  571, 
<b>T_IS_GREATER_OR_EQUAL</b> =  572, 
<b>T_IS_IDENTICAL</b> =  573, 
<br/>
&#160;&#160;<b>T_IS_NOT_EQUAL</b> =  574, 
<b>T_IS_NOT_IDENTICAL</b> =  575, 
<b>T_ISSET</b> =  576, 
<b>T_IS_SMALLER_OR_EQUAL</b> =  577, 
<br/>
&#160;&#160;<b>T_LINE</b> =  578, 
<b>T_LIST</b> =  579, 
<b>T_LNUMBER</b> =  580, 
<b>T_LOGICAL_AND</b> =  581, 
<br/>
&#160;&#160;<b>T_LOGICAL_OR</b> =  582, 
<b>T_LOGICAL_XOR</b> =  583, 
<b>T_METHOD_C</b> =  584, 
<b>T_MINUS_EQUAL</b> =  585, 
<br/>
&#160;&#160;<b>T_MOD_EQUAL</b> =  586, 
<b>T_MUL_EQUAL</b> =  587, 
<b>T_NAMESPACE</b> =  588, 
<b>T_NEW</b> =  589, 
<br/>
&#160;&#160;<b>T_NS_C</b> =  590, 
<b>T_NS_SEPARATOR</b> =  591, 
<b>T_NUM_STRING</b> =  592, 
<b>T_OBJECT_CAST</b> =  593, 
<br/>
&#160;&#160;<b>T_OBJECT_OPERATOR</b> =  594, 
<b>T_OPEN_TAG</b> =  595, 
<b>T_OPEN_TAG_WITH_ECHO</b> =  596, 
<b>T_OR_EQUAL</b> =  597, 
<br/>
&#160;&#160;<b>T_PAAMAYIM_NEKUDOTAYIM</b> =  598, 
<b>T_PLUS_EQUAL</b> =  599, 
<b>T_PRINT</b> =  600, 
<b>T_PRIVATE</b> =  601, 
<br/>
&#160;&#160;<b>T_PROTECTED</b> =  602, 
<b>T_PUBLIC</b> =  603, 
<b>T_REQUIRE</b> =  604, 
<b>T_REQUIRE_ONCE</b> =  605, 
<br/>
&#160;&#160;<b>T_RETURN</b> =  606, 
<b>T_SL</b> =  607, 
<b>T_SL_EQUAL</b> =  608, 
<b>T_SR</b> =  609, 
<br/>
&#160;&#160;<b>T_SR_EQUAL</b> =  610, 
<b>T_START_HEREDOC</b> =  611, 
<b>T_STATIC</b> =  612, 
<b>T_STRING</b> =  613, 
<br/>
&#160;&#160;<b>T_STRING_CAST</b> =  614, 
<b>T_STRING_VARNAME</b> =  615, 
<b>T_SWITCH</b> =  616, 
<b>T_THROW</b> =  617, 
<br/>
&#160;&#160;<b>T_TRAIT</b> =  618, 
<b>T_TRAIT_C</b> =  619, 
<b>T_TRY</b> =  620, 
<b>T_UNSET</b> =  621, 
<br/>
&#160;&#160;<b>T_UNSET_CAST</b> =  622, 
<b>T_USE</b> =  623, 
<b>T_VAR</b> =  624, 
<b>T_VARIABLE</b> =  625, 
<br/>
&#160;&#160;<b>T_WHILE</b> =  626, 
<b>T_WHITESPACE</b> =  627, 
<b>T_XOR_EQUAL</b> =  628
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#a94178fe1b2157a6ff6cae428cac89dd1">YYCONDTYPE</a> { <br/>
&#160;&#160;<b>yycSCRIPT</b>, 
<b>yycLINE_COMMENT</b>, 
<b>yycMULTI_LINE_COMMENT</b>, 
<b>yycDOC_COMMENT</b>, 
<br/>
&#160;&#160;<b>yycSINGLE_QUOTE_STRING</b>, 
<b>yycDOUBLE_QUOTE_STRING</b>, 
<b>yycDOUBLE_QUOTE_STRING_VARIABLE</b>, 
<b>yycHEREDOC</b>, 
<br/>
&#160;&#160;<b>yycNOWDOC</b>, 
<b>yycINLINE_HTML</b>, 
<b>yycPROPERTY</b>, 
<b>yycBACKTICK</b>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#a83c967b0d9957de83017815409f36c04">FullLex</a> (<a class="el" href="unionpelet_1_1ParserType.html">pelet::ParserType</a> *value, <a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;analyzer, <a class="el" href="classpelet_1_1FullParserObserverClass.html">pelet::FullParserObserverClass</a> &amp;observers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#a97c470b6d96000deed4b7e94a9902cad">FullGrammarError</a> (<a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;analyzer, <a class="el" href="classpelet_1_1FullParserObserverClass.html">pelet::FullParserObserverClass</a> &amp;observers, std::string msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#a30431d5f712e9903b37d12b0288af443">LintLex</a> (int *value, <a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;analyzer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#af4a3521893f76192f5ab3675bc8d63ab">LintGrammarError</a> (<a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;analyzer, std::string msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UnicodeString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#ade2acbcb03546524989cbe7920000733">ReturnTypeFromPhpDocComment</a> (const UnicodeString &amp;phpDocComment, bool varAnnotation, const <a class="el" href="classpelet_1_1ScopeClass.html">pelet::ScopeClass</a> &amp;scope, const <a class="el" href="classpelet_1_1QualifiedNameClass.html">pelet::QualifiedNameClass</a> &amp;currentNamespace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UnicodeString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#ab4fe0ddf42cd4ec0885f5b085c400561">PhpDocTypeToAbsoluteClassname</a> (UnicodeString phpDocType, const <a class="el" href="classpelet_1_1ScopeClass.html">pelet::ScopeClass</a> &amp;scope, const <a class="el" href="classpelet_1_1QualifiedNameClass.html">pelet::QualifiedNameClass</a> &amp;currentNamespace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#afcf663182409dce7e3c11e4ba717b429">CreateMagicMethodsAndProperties</a> (std::vector&lt; <a class="el" href="classpelet_1_1AstItemClass.html">pelet::AstItemClass</a> * &gt; &amp;allAstItems, <a class="el" href="classpelet_1_1StatementListClass.html">pelet::StatementListClass</a> *statements, const <a class="el" href="classpelet_1_1ScopeClass.html">pelet::ScopeClass</a> &amp;scope, const <a class="el" href="classpelet_1_1QualifiedNameClass.html">pelet::QualifiedNameClass</a> &amp;currentNamespace, const UnicodeString &amp;phpDocComment, const int lineNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#afdfbaa6a55436f4af12740ae60daee77">Next53Token</a> (<a class="el" href="classpelet_1_1BufferClass.html">BufferClass</a> *buffer, <a class="el" href="namespacepelet.html#a94178fe1b2157a6ff6cae428cac89dd1">YYCONDTYPE</a> &amp;condition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#a9fa6908644fd4d7e6944c23dcb583e82">Next54Token</a> (<a class="el" href="classpelet_1_1BufferClass.html">BufferClass</a> *buffer, <a class="el" href="namespacepelet.html#a94178fe1b2157a6ff6cae428cac89dd1">YYCONDTYPE</a> &amp;condition)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#a0d050bea13c714fc4ba5a17197845134">ResourceLex</a> (<a class="el" href="namespacepelet.html#a637f7e5f150b98510952ff25157159e6">pelet::ResourceParserTypeClass</a> *value, <a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;analyzer, <a class="el" href="classpelet_1_1ResourceParserObserverClass.html">pelet::ResourceParserObserverClass</a> &amp;observers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#a6d7e8c6fe5610aba8828ce8c4a3693f2">ResourceGrammarError</a> (<a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;analyzer, <a class="el" href="classpelet_1_1ResourceParserObserverClass.html">pelet::ResourceParserObserverClass</a> &amp;observers, std::string msg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool PELET_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#ad30c2f10ca3695104ce46de9e561654d">IsTerminatingToken</a> (int token)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#aff764a85748238489a25153b71274170">SkipToIdentifier</a> (<a class="el" href="classpelet_1_1BufferClass.html">BufferClass</a> *buffer, UnicodeString identifier)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#a59ae8338b40b1bfc4fc6b1949ea13677">HandleNowdoc</a> (<a class="el" href="classpelet_1_1BufferClass.html">BufferClass</a> *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepelet.html#aefe3467c101aa749c5731896fa0f2703">HandleHeredoc</a> (<a class="el" href="classpelet_1_1BufferClass.html">BufferClass</a> *buffer)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This software is released under the terms of the MIT License</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<dl class="copyright"><dt><b>Copyright:</b></dt><dd>2009-2012 Roberto Perpuly  <a href="http://www.opensource.org/licenses/mit-license.php">http://www.opensource.org/licenses/mit-license.php</a> The MIT License</dd></dl>
<p>The MIT License</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<dl class="copyright"><dt><b>Copyright:</b></dt><dd>2009-2012 Roberto Perpuly  <a href="http://www.opensource.org/licenses/mit-license.php">http://www.opensource.org/licenses/mit-license.php</a> The MIT License</dd></dl>
<p>This software is released under the terms of the MIT License</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<dl class="copyright"><dt><b>Copyright:</b></dt><dd>2012 Roberto Perpuly  <a href="http://www.opensource.org/licenses/mit-license.php">http://www.opensource.org/licenses/mit-license.php</a> The MIT License</dd></dl>
<p>This software is released under the terms of the MIT License</p>
<p>Permission is hereby granted free of charge to any person obtaining a copy of this software and associated documentation files (the "Software") to deal in the Software without restriction including without limitation the rights to use copy modify merge publish distribute sublicense and/or sell copies of the Software and to permit persons to whom the Software is furnished to do so subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND EXPRESS OR IMPLIED INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM DAMAGES OR OTHER LIABILITY WHETHER IN AN ACTION OF CONTRACT TORT OR OTHERWISE ARISING FROM OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<dl class="copyright"><dt><b>Copyright:</b></dt><dd>2009-2012 Roberto Perpuly  <a href="http://www.opensource.org/licenses/mit-license.php">http://www.opensource.org/licenses/mit-license.php</a> The MIT License </dd></dl>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a28f4ac5c84bc263188edfc784ae4a106"></a><!-- doxytag: member="pelet::ParserTypeClass" ref="a28f4ac5c84bc263188edfc784ae4a106" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionpelet_1_1ParserType.html">pelet::ParserType</a>  <a class="el" href="namespacepelet.html#a28f4ac5c84bc263188edfc784ae4a106">pelet::ParserTypeClass</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the parser type that the bison parser uses. A grammar rules outputs to exactly ONE of these properties </p>

</div>
</div>
<a class="anchor" id="a637f7e5f150b98510952ff25157159e6"></a><!-- doxytag: member="pelet::ResourceParserTypeClass" ref="a637f7e5f150b98510952ff25157159e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionpelet_1_1ResourceParserType.html">pelet::ResourceParserType</a>  <a class="el" href="namespacepelet.html#a637f7e5f150b98510952ff25157159e6">pelet::ResourceParserTypeClass</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the parser type that the bison parser uses. A grammar rule outputs to exactly ONE of these . All of these pointers will be Adopt()'ed by <a class="el" href="classpelet_1_1ResourceParserObserverClass.html">ResourceParserObserverClass</a>; that way they get cleaned up when the <a class="el" href="classpelet_1_1ResourceParserObserverClass.html">ResourceParserObserverClass</a> object goes out of scope. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a2f19d390f08da8ac1d5fd8125f412429"></a><!-- doxytag: member="pelet::Tokens" ref="a2f19d390f08da8ac1d5fd8125f412429" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepelet.html#a2f19d390f08da8ac1d5fd8125f412429">pelet::Tokens</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These tokens will be 'shared' among the multiple PHP grammars. We want to use the same numbers across all grammars, but when defining a grammar we cannot use #defines or use our own enum. Therefore, we must use numbers when defining the token types. But, this also means we must be real careful and use the exact same numbers. This list of #defines below was generated using this bit of scripting:</p>
<p>cat ~/workspace/php-5.4.0/Zend/zend_language_parser.y \ | grep "%token" | cut -d ' ' -f 1-2 | sort | uniq | awk '{ print "#define ", $2, " ", 500 + NR; }' | grep -v " END "</p>
<p>where we take all the original grammar files, keep only the token declarations, figure out all unique tokens, and generate a #define with a unique number for each token (minus the END token, which bison requires to always be zero </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a2f19d390f08da8ac1d5fd8125f412429a70047db2eb71ae6a6cdf07e4d8cd568d"></a><!-- doxytag: member="T_END" ref="a2f19d390f08da8ac1d5fd8125f412429a70047db2eb71ae6a6cdf07e4d8cd568d" args="" -->T_END</em>&nbsp;</td><td>
<p>token the signifies the end of the input </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a94178fe1b2157a6ff6cae428cac89dd1"></a><!-- doxytag: member="pelet::YYCONDTYPE" ref="a94178fe1b2157a6ff6cae428cac89dd1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepelet.html#a94178fe1b2157a6ff6cae428cac89dd1">pelet::YYCONDTYPE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The lexer has different rules based on where in the source code a specific token is. The various states are:</p>
<p>INLINE_HTML: in this state the lexer will skip over all tokens and stop (right before) the open tag SCRIPT: in this state all of the php keywords and symbols are honored. For example "if" is an T_IF token and not an identifer. LINE_COMMENT: single line comment MULTI_LINE_COMMENT: multi line comments that do not start with "/" "*" "*" DOC_COMMENT: multi line comments that start with "/" "*" "*" SINGLE_QUOTE_STRING: string constants enclosed with single quotes DOUBLE_QUOTE_STRING: string constants enclosed with double quotes DOUBLE_QUOTE_STRING_VARIABLE: a variable inside of a double-quoted string HEREDOC: string constant NOWDOC: string constant PROPERTY: in this state keywords are NOT honored; any alphanumeric string will labeled as an identifier. For example; in php an object is allowed to have a property called "list" BACKTICK: in this state the lexer will not honor any keywords or symbols. Note that this is different than the PHP lexer; the PHP lexer handles embedded variables but that functionality is not needed by the editor. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="afcf663182409dce7e3c11e4ba717b429"></a><!-- doxytag: member="pelet::CreateMagicMethodsAndProperties" ref="afcf663182409dce7e3c11e4ba717b429" args="(std::vector&lt; pelet::AstItemClass * &gt; &amp;allAstItems, pelet::StatementListClass *statements, const pelet::ScopeClass &amp;scope, const pelet::QualifiedNameClass &amp;currentNamespace, const UnicodeString &amp;phpDocComment, const int lineNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacepelet.html#afcf663182409dce7e3c11e4ba717b429">pelet::CreateMagicMethodsAndProperties</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classpelet_1_1AstItemClass.html">pelet::AstItemClass</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>allAstItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1StatementListClass.html">pelet::StatementListClass</a> *&#160;</td>
          <td class="paramname"><em>statements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpelet_1_1ScopeClass.html">pelet::ScopeClass</a> &amp;&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpelet_1_1QualifiedNameClass.html">pelet::QualifiedNameClass</a> &amp;&#160;</td>
          <td class="paramname"><em>currentNamespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnicodeString &amp;&#160;</td>
          <td class="paramname"><em>phpDocComment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lineNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>parses out the given PHPDoc comment and creates property or method declarations for @property, @property-read, @property-write, and @method doc tags. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">allAstItems</td><td>the created items will be appended to this list </td></tr>
    <tr><td class="paramname">statement</td><td>the declarations that are created will be added to this list. to keep things consistant, the pointers added to statements will be added to allAstItems that way allAstItems manages the pointers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97c470b6d96000deed4b7e94a9902cad"></a><!-- doxytag: member="pelet::FullGrammarError" ref="a97c470b6d96000deed4b7e94a9902cad" args="(pelet::LexicalAnalyzerClass &amp;analyzer, pelet::FullParserObserverClass &amp;observers, std::string msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacepelet.html#a97c470b6d96000deed4b7e94a9902cad">pelet::FullGrammarError</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1FullParserObserverClass.html">pelet::FullParserObserverClass</a> &amp;&#160;</td>
          <td class="paramname"><em>observers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>this function will set the error that comes from bison and put it in the LexicalAnalyzer class. </p>

</div>
</div>
<a class="anchor" id="a83c967b0d9957de83017815409f36c04"></a><!-- doxytag: member="pelet::FullLex" ref="a83c967b0d9957de83017815409f36c04" args="(pelet::ParserType *value, pelet::LexicalAnalyzerClass &amp;analyzer, pelet::FullParserObserverClass &amp;observers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespacepelet.html#a83c967b0d9957de83017815409f36c04">pelet::FullLex</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionpelet_1_1ParserType.html">pelet::ParserType</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1FullParserObserverClass.html">pelet::FullParserObserverClass</a> &amp;&#160;</td>
          <td class="paramname"><em>observers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will get the next token from the lexer and will create a new SemanticValue (token + lexeme) from it. </p>

</div>
</div>
<a class="anchor" id="aefe3467c101aa749c5731896fa0f2703"></a><!-- doxytag: member="pelet::HandleHeredoc" ref="aefe3467c101aa749c5731896fa0f2703" args="(BufferClass *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespacepelet.html#aefe3467c101aa749c5731896fa0f2703">pelet::HandleHeredoc</a> </td>
          <td>(</td>
          <td class="paramtype">BufferClass *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will advance the current pointer of the buffer all the way until it encounters the end of the nowdoc. It will leave the ending semicolon in the stream to be consumed next.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the content being lexed. This function will NOT own the pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int token; could be ERROR_UNTERMINATED_STRING </dd></dl>

</div>
</div>
<a class="anchor" id="a59ae8338b40b1bfc4fc6b1949ea13677"></a><!-- doxytag: member="pelet::HandleNowdoc" ref="a59ae8338b40b1bfc4fc6b1949ea13677" args="(BufferClass *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespacepelet.html#a59ae8338b40b1bfc4fc6b1949ea13677">pelet::HandleNowdoc</a> </td>
          <td>(</td>
          <td class="paramtype">BufferClass *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will advance the current pointer of the buffer all the way until it encounters the end of the heredoc. It will leave the ending semicolon in the stream to be consumed next.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the content being lexed. This function will NOT own the pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int token; could be ERROR_UNTERMINATED_STRING </dd></dl>

</div>
</div>
<a class="anchor" id="ad30c2f10ca3695104ce46de9e561654d"></a><!-- doxytag: member="pelet::IsTerminatingToken" ref="ad30c2f10ca3695104ce46de9e561654d" args="(int token)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PELET_API <a class="el" href="namespacepelet.html#ad30c2f10ca3695104ce46de9e561654d">pelet::IsTerminatingToken</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns TRUE if the given token signifies the end of tile. Unfortunately due to bison insisting that all token be positive the only way to flag unterminating string is to give it a positive token numberand this prevents us from doing easy checks for end of file such as token &gt; 0 </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool if TRUE caller should stop lexing as there is no more input. </dd></dl>

</div>
</div>
<a class="anchor" id="af4a3521893f76192f5ab3675bc8d63ab"></a><!-- doxytag: member="pelet::LintGrammarError" ref="af4a3521893f76192f5ab3675bc8d63ab" args="(pelet::LexicalAnalyzerClass &amp;analyzer, std::string msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacepelet.html#af4a3521893f76192f5ab3675bc8d63ab">pelet::LintGrammarError</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will set the error that comes from bison and put it in the LexicalAnalyzer class.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">analyzer</td><td>to get the line, and character numbers where the error ocurred </td></tr>
    <tr><td class="paramname">msg</td><td>the error message, generated by Bison </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30431d5f712e9903b37d12b0288af443"></a><!-- doxytag: member="pelet::LintLex" ref="a30431d5f712e9903b37d12b0288af443" args="(int *value, pelet::LexicalAnalyzerClass &amp;analyzer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespacepelet.html#a30431d5f712e9903b37d12b0288af443">pelet::LintLex</a> </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will get the next token from the lexer and will set the value parameter to that token. Note that this function will consume any comments and PHP doc comments because the PHP grammar does not use them.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the token from the analyzer </td></tr>
    <tr><td class="paramname">analyzer</td><td>to get the next token from the PHP source being parsed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afdfbaa6a55436f4af12740ae60daee77"></a><!-- doxytag: member="pelet::Next53Token" ref="afdfbaa6a55436f4af12740ae60daee77" args="(BufferClass *buffer, YYCONDTYPE &amp;condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespacepelet.html#afdfbaa6a55436f4af12740ae60daee77">pelet::Next53Token</a> </td>
          <td>(</td>
          <td class="paramtype">BufferClass *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">YYCONDTYPE &amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the next token from the given buffer. Checking for the end is not as simple as checking for T_EOF, you will need to call pelet::TokenClass::IsTerminatingToken() to ensure that the end of stream has been reached (since a lexer can end with EOF, an unterminated string, or an unterminated comment).</p>
<p>* This lexer will handle source code for PHP version 5.3</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">BufferClass*</td><td>buffer contains the code to be tokenized. This function will NOT own the pointer. </td></tr>
    <tr><td class="paramname">YYCONDTYPE</td><td>&amp;condition the current state the the parser is in. this needs to be an argument to avoid global variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int the next token. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fa6908644fd4d7e6944c23dcb583e82"></a><!-- doxytag: member="pelet::Next54Token" ref="a9fa6908644fd4d7e6944c23dcb583e82" args="(BufferClass *buffer, YYCONDTYPE &amp;condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespacepelet.html#a9fa6908644fd4d7e6944c23dcb583e82">pelet::Next54Token</a> </td>
          <td>(</td>
          <td class="paramtype">BufferClass *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">YYCONDTYPE &amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the next token from the given buffer. Checking for the end is not as simple as checking for T_EOF, you will need to call pelet::TokenClass::IsTerminatingToken() to ensure that the end of stream has been reached (since a lexer can end with EOF, an unterminated string, or an unterminated comment).</p>
<p>This lexer will handle source code for PHP version 5.4</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">BufferClass*</td><td>buffer contains the code to be tokenized. This function will NOT own the pointer. </td></tr>
    <tr><td class="paramname">YYCONDTYPE</td><td>&amp;condition the current state the the parser is in. this needs to be an argument to avoid global variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int the next token. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4fe0ddf42cd4ec0885f5b085c400561"></a><!-- doxytag: member="pelet::PhpDocTypeToAbsoluteClassname" ref="ab4fe0ddf42cd4ec0885f5b085c400561" args="(UnicodeString phpDocType, const pelet::ScopeClass &amp;scope, const pelet::QualifiedNameClass &amp;currentNamespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UnicodeString <a class="el" href="namespacepelet.html#ab4fe0ddf42cd4ec0885f5b085c400561">pelet::PhpDocTypeToAbsoluteClassname</a> </td>
          <td>(</td>
          <td class="paramtype">UnicodeString&#160;</td>
          <td class="paramname"><em>phpDocType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpelet_1_1ScopeClass.html">pelet::ScopeClass</a> &amp;&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpelet_1_1QualifiedNameClass.html">pelet::QualifiedNameClass</a> &amp;&#160;</td>
          <td class="paramname"><em>currentNamespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Turn a PHPDoc type into a fully qualified class name. The phpdoc type will get qualified according to the same PHP rules as a type hint; the current namespace and any aliases will be correctly accounted for.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">phpDocType</td><td>the parsed type in the PHPDoc, ie. in "@return StringClass" then this parameter should be "StringClass" </td></tr>
    <tr><td class="paramname">scope</td><td>the scope where the PHPDoc comment is located in </td></tr>
    <tr><td class="paramname">currentNamespace</td><td>the current namespace we are in </td></tr>
    <tr><td class="paramname">the</td><td>fully qualified class name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d7e8c6fe5610aba8828ce8c4a3693f2"></a><!-- doxytag: member="pelet::ResourceGrammarError" ref="a6d7e8c6fe5610aba8828ce8c4a3693f2" args="(pelet::LexicalAnalyzerClass &amp;analyzer, pelet::ResourceParserObserverClass &amp;observers, std::string msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacepelet.html#a6d7e8c6fe5610aba8828ce8c4a3693f2">pelet::ResourceGrammarError</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1ResourceParserObserverClass.html">pelet::ResourceParserObserverClass</a> &amp;&#160;</td>
          <td class="paramname"><em>observers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will set the error that comes from bison and put it in the LexicalAnalyzer class.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">analyzer</td><td>to get the line, and character numbers where the error ocurred </td></tr>
    <tr><td class="paramname">observers</td><td>not used </td></tr>
    <tr><td class="paramname">msg</td><td>the error message, generated by Bison </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d050bea13c714fc4ba5a17197845134"></a><!-- doxytag: member="pelet::ResourceLex" ref="a0d050bea13c714fc4ba5a17197845134" args="(pelet::ResourceParserTypeClass *value, pelet::LexicalAnalyzerClass &amp;analyzer, pelet::ResourceParserObserverClass &amp;observers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespacepelet.html#a0d050bea13c714fc4ba5a17197845134">pelet::ResourceLex</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepelet.html#a637f7e5f150b98510952ff25157159e6">pelet::ResourceParserTypeClass</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1LexicalAnalyzerClass.html">pelet::LexicalAnalyzerClass</a> &amp;&#160;</td>
          <td class="paramname"><em>analyzer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpelet_1_1ResourceParserObserverClass.html">pelet::ResourceParserObserverClass</a> &amp;&#160;</td>
          <td class="paramname"><em>observers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The resource parse will call this method to get the next token. This function will create the correct <a class="el" href="classpelet_1_1AstItemClass.html">AstItemClass</a> instance according to the token that is parsed. For example, when the token from the analyzer is T_STRING, this function will create a <a class="el" href="classpelet_1_1SemanticValueClass.html">SemanticValueClass</a> and will initialize the lexeme properly. It will also consume all comment tokens because there are no grammar rules for them. For PHP doc comments, they are 'attached' to the lexeme (SemanticValue instance). Finally, this function will also take care of any 'magic method' declarations in PHP Doc comments.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the parser union to fill in </td></tr>
    <tr><td class="paramname">analyzer</td><td>to get the next token from the PHP source being parsed </td></tr>
    <tr><td class="paramname">observers</td><td>needed to keep track of the new AstItem instance that is created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade2acbcb03546524989cbe7920000733"></a><!-- doxytag: member="pelet::ReturnTypeFromPhpDocComment" ref="ade2acbcb03546524989cbe7920000733" args="(const UnicodeString &amp;phpDocComment, bool varAnnotation, const pelet::ScopeClass &amp;scope, const pelet::QualifiedNameClass &amp;currentNamespace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UnicodeString <a class="el" href="namespacepelet.html#ade2acbcb03546524989cbe7920000733">pelet::ReturnTypeFromPhpDocComment</a> </td>
          <td>(</td>
          <td class="paramtype">const UnicodeString &amp;&#160;</td>
          <td class="paramname"><em>phpDocComment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>varAnnotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpelet_1_1ScopeClass.html">pelet::ScopeClass</a> &amp;&#160;</td>
          <td class="paramname"><em>scope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpelet_1_1QualifiedNameClass.html">pelet::QualifiedNameClass</a> &amp;&#160;</td>
          <td class="paramname"><em>currentNamespace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the return type from the '@return' / '@var' annotation</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>UnicodeString&amp; phpDocComment the comment </td></tr>
    <tr><td class="paramname">bool</td><td>varAnnotation if false, will return the word after '@var', else return the word after '@return' </td></tr>
    <tr><td class="paramname">scope</td><td>the scope where the PHPDoc comment is located in </td></tr>
    <tr><td class="paramname">currentNamespace</td><td>the current namespace we are in </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>UnicodeString </dd></dl>

</div>
</div>
<a class="anchor" id="aff764a85748238489a25153b71274170"></a><!-- doxytag: member="pelet::SkipToIdentifier" ref="aff764a85748238489a25153b71274170" args="(BufferClass *buffer, UnicodeString identifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="namespacepelet.html#aff764a85748238489a25153b71274170">pelet::SkipToIdentifier</a> </td>
          <td>(</td>
          <td class="paramtype">BufferClass *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnicodeString&#160;</td>
          <td class="paramname"><em>identifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will advance the current pointer of the buffer all the way until it encounters the given identifier on a line. (the end of a heredoc / nowdoc).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>the content being lexed. This function will NOT own the pointer. </td></tr>
    <tr><td class="paramname">identifier</td><td>the identifier to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success; ERROR_UNTERMINATED_STRING if identifier was not found </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 30 2014 22:08:58 for pelet by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
